<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>FRC 2026 ‚Äî Basketball Arc Shooter Sim</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;600;700&family=Outfit:wght@300;400;600;800&display=swap");

      :root {
        --bg: #07090d;
        --panel: rgba(10, 13, 20, 0.94);
        --border: rgba(56, 189, 248, 0.1);
        --accent: #38bdf8;
        --accent2: #f472b6;
        --accent3: #a78bfa;
        --green: #4ade80;
        --orange: #fb923c;
        --red: #f87171;
        --yellow: #fbbf24;
        --text: #e2e8f0;
        --muted: #64748b;
        --dim: #1e293b;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: var(--bg);
        color: var(--text);
        font-family: "Outfit", sans-serif;
        overflow: hidden;
        height: 100vh;
      }

      canvas {
        display: block;
      }

      .top-bar {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: 48px;
        background: var(--panel);
        border-bottom: 1px solid var(--border);
        display: flex;
        align-items: center;
        padding: 0 20px;
        z-index: 100;
        backdrop-filter: blur(20px);
        gap: 14px;
      }
      .top-bar .logo {
        font-family: "JetBrains Mono", monospace;
        font-weight: 700;
        font-size: 13px;
        color: var(--accent);
        letter-spacing: 2px;
      }
      .top-bar .sep {
        width: 1px;
        height: 20px;
        background: var(--dim);
      }
      .top-bar .title {
        font-weight: 300;
        font-size: 13px;
        color: var(--muted);
      }
      .status-pill {
        margin-left: auto;
        display: flex;
        align-items: center;
        gap: 6px;
        font-family: "JetBrains Mono", monospace;
        font-size: 10px;
        padding: 3px 10px;
        border-radius: 16px;
        background: rgba(74, 222, 128, 0.06);
        border: 1px solid rgba(74, 222, 128, 0.15);
        color: var(--green);
      }
      .status-pill .dot {
        width: 5px;
        height: 5px;
        border-radius: 50%;
        background: var(--green);
        animation: blink 2s infinite;
      }
      @keyframes blink {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.3;
        }
      }

      /* ‚îÄ‚îÄ PANELS ‚îÄ‚îÄ */
      .panel {
        position: fixed;
        top: 60px;
        width: 280px;
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 10px;
        z-index: 100;
        backdrop-filter: blur(20px);
        overflow: hidden;
        max-height: calc(100vh - 76px);
        overflow-y: auto;
      }
      .panel::-webkit-scrollbar {
        width: 3px;
      }
      .panel::-webkit-scrollbar-thumb {
        background: var(--dim);
        border-radius: 2px;
      }
      .panel.left {
        left: 14px;
      }
      .panel.right {
        right: 14px;
        width: 260px;
      }

      .p-head {
        padding: 12px 16px;
        border-bottom: 1px solid var(--border);
        font-family: "JetBrains Mono", monospace;
        font-size: 10px;
        font-weight: 600;
        letter-spacing: 1.5px;
        text-transform: uppercase;
        color: var(--accent);
      }
      .p-sec {
        padding: 12px 16px;
        border-bottom: 1px solid rgba(56, 189, 248, 0.05);
      }
      .sec-label {
        font-size: 9px;
        font-weight: 600;
        letter-spacing: 1px;
        text-transform: uppercase;
        color: var(--muted);
        margin-bottom: 8px;
      }

      .row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 6px;
      }
      .row label {
        font-size: 11px;
        color: var(--text);
      }
      .row .val {
        font-family: "JetBrains Mono", monospace;
        font-size: 11px;
        color: var(--accent);
        min-width: 55px;
        text-align: right;
      }

      input[type="range"] {
        width: 100%;
        height: 3px;
        -webkit-appearance: none;
        appearance: none;
        background: var(--dim);
        border-radius: 2px;
        outline: none;
        margin: 3px 0 10px;
      }
      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: var(--accent);
        cursor: pointer;
        box-shadow: 0 0 8px rgba(56, 189, 248, 0.35);
      }

      .btn {
        width: 100%;
        padding: 9px;
        border: 1px solid var(--accent2);
        background: rgba(244, 114, 182, 0.07);
        color: var(--accent2);
        font-family: "JetBrains Mono", monospace;
        font-size: 11px;
        font-weight: 600;
        letter-spacing: 1px;
        text-transform: uppercase;
        border-radius: 7px;
        cursor: pointer;
        transition: all 0.2s;
      }
      .btn:hover {
        background: rgba(244, 114, 182, 0.18);
        box-shadow: 0 0 16px rgba(244, 114, 182, 0.15);
      }

      .toggle-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 6px;
      }
      .toggle-row label {
        font-size: 11px;
      }
      .toggle {
        position: relative;
        width: 32px;
        height: 18px;
        background: var(--dim);
        border-radius: 9px;
        cursor: pointer;
        transition: background 0.2s;
      }
      .toggle.on {
        background: var(--accent);
      }
      .toggle::after {
        content: "";
        position: absolute;
        top: 2.5px;
        left: 2.5px;
        width: 13px;
        height: 13px;
        border-radius: 50%;
        background: #fff;
        transition: transform 0.2s;
      }
      .toggle.on::after {
        transform: translateX(14px);
      }

      /* telem */
      .t-row {
        display: flex;
        justify-content: space-between;
        padding: 5px 16px;
        font-size: 11px;
        border-bottom: 1px solid rgba(56, 189, 248, 0.03);
      }
      .t-label {
        color: var(--muted);
        font-size: 10px;
      }
      .t-val {
        font-family: "JetBrains Mono", monospace;
        font-size: 11px;
        color: var(--text);
      }
      .t-val.good {
        color: var(--green);
      }
      .t-val.warn {
        color: var(--orange);
      }
      .t-val.bad {
        color: var(--red);
      }

      /* bottom bar */
      .bot-bar {
        position: fixed;
        bottom: 16px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 20px;
        align-items: center;
        z-index: 100;
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px 28px;
        backdrop-filter: blur(16px);
      }
      .stat {
        text-align: center;
      }
      .stat .v {
        font-family: "JetBrains Mono", monospace;
        font-size: 17px;
        font-weight: 700;
        display: block;
      }
      .stat .l {
        font-size: 9px;
        color: var(--muted);
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      .stat .v.a {
        color: var(--accent);
      }
      .stat .v.p {
        color: var(--accent2);
      }
      .stat .v.u {
        color: var(--accent3);
      }
      .stat .v.g {
        color: var(--green);
      }
      .stat .v.y {
        color: var(--yellow);
      }

      .ready-pill {
        font-family: "JetBrains Mono", monospace;
        font-size: 11px;
        font-weight: 600;
        letter-spacing: 1.5px;
        text-transform: uppercase;
        padding: 6px 18px;
        border-radius: 20px;
      }
      .ready-pill.ok {
        background: rgba(74, 222, 128, 0.08);
        border: 1px solid rgba(74, 222, 128, 0.25);
        color: var(--green);
      }
      .ready-pill.no {
        background: rgba(251, 146, 60, 0.08);
        border: 1px solid rgba(251, 146, 60, 0.2);
        color: var(--orange);
      }

      .keys {
        position: fixed;
        bottom: 16px;
        right: 14px;
        z-index: 100;
        font-family: "JetBrains Mono", monospace;
        font-size: 9px;
        color: var(--muted);
        text-align: right;
        line-height: 2;
      }
      .keys kbd {
        background: var(--dim);
        padding: 1px 5px;
        border-radius: 3px;
        color: var(--text);
        font-size: 9px;
      }

      /* Score popup */
      .score-popup {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        font-family: "JetBrains Mono", monospace;
        font-size: 48px;
        font-weight: 800;
        color: var(--green);
        z-index: 200;
        pointer-events: none;
        text-shadow: 0 0 40px rgba(74, 222, 128, 0.6);
        transition:
          transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1),
          opacity 0.5s;
        opacity: 0;
      }
      .score-popup.show {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
      }
      .score-popup.miss {
        color: var(--red);
        text-shadow: 0 0 40px rgba(248, 113, 113, 0.6);
      }
    </style>
  </head>
  <body>
    <div class="top-bar">
      <span class="logo">FRC 2026</span><span class="sep"></span>
      <span class="title">REBUILT ‚Äî Basketball Arc Shooter Physics</span>
      <div class="status-pill"><span class="dot"></span>LIVE SIM</div>
    </div>

    <!-- LEFT PANEL: CONTROLS -->
    <div class="panel left">
      <div class="p-head">‚öô Controls</div>
      <div class="p-sec">
        <div class="sec-label">Target</div>
        <div class="row">
          <label>Distance</label><span class="val" id="v-dist">3.5 m</span>
        </div>
        <input
          type="range"
          id="s-dist"
          min="1.2"
          max="6.5"
          step="0.1"
          value="3.5"
        />
        <div class="row">
          <label>Turret Angle</label><span class="val" id="v-turret">0¬∞</span>
        </div>
        <input
          type="range"
          id="s-turret"
          min="-175"
          max="175"
          step="1"
          value="0"
        />
      </div>
      <div class="p-sec">
        <div class="sec-label">Physics Tuning</div>
        <div class="row">
          <label>Efficiency</label><span class="val" id="v-eff">0.30</span>
        </div>
        <input
          type="range"
          id="s-eff"
          min="0.10"
          max="0.60"
          step="0.01"
          value="0.30"
        />
        <div class="row">
          <label>Apex Clearance</label
          ><span class="val" id="v-apex">0.30 m</span>
        </div>
        <input
          type="range"
          id="s-apex"
          min="0.05"
          max="1.0"
          step="0.05"
          value="0.30"
        />
        <div class="row">
          <label>Bias Near</label><span class="val" id="v-bn">1.00</span>
        </div>
        <input
          type="range"
          id="s-bn"
          min="0.80"
          max="1.40"
          step="0.01"
          value="1.00"
        />
        <div class="row">
          <label>Bias Far</label><span class="val" id="v-bf">1.00</span>
        </div>
        <input
          type="range"
          id="s-bf"
          min="0.80"
          max="1.40"
          step="0.01"
          value="1.00"
        />
      </div>
      <div class="p-sec">
        <div class="sec-label">Display</div>
        <div class="toggle-row">
          <label>Trajectory Arc</label>
          <div class="toggle on" id="tg-traj" onclick="tog('traj')"></div>
        </div>
        <div class="toggle-row">
          <label>Apex Marker</label>
          <div class="toggle on" id="tg-apexm" onclick="tog('apexm')"></div>
        </div>
        <div class="toggle-row">
          <label>Clearance Lines</label>
          <div class="toggle on" id="tg-clear" onclick="tog('clear')"></div>
        </div>
        <div class="toggle-row">
          <label>Side View Guide</label>
          <div class="toggle on" id="tg-side" onclick="tog('side')"></div>
        </div>
        <div class="toggle-row">
          <label>Auto-Rotate Cam</label>
          <div class="toggle" id="tg-rot" onclick="tog('rot')"></div>
        </div>
      </div>
      <div class="p-sec">
        <button class="btn" onclick="fireBall()">
          üî• FIRE ‚Äî <kbd>Space</kbd>
        </button>
      </div>
    </div>

    <!-- RIGHT PANEL: TELEMETRY -->
    <div class="panel right">
      <div class="p-head">üìä Telemetry</div>
      <div class="t-row">
        <span class="t-label">Flywheel</span
        ><span class="t-val" id="t-fw">‚Äî</span>
      </div>
      <div class="t-row">
        <span class="t-label">Hood Angle</span
        ><span class="t-val" id="t-hood">‚Äî</span>
      </div>
      <div class="t-row">
        <span class="t-label">Exit Angle</span
        ><span class="t-val" id="t-ea">‚Äî</span>
      </div>
      <div class="t-row">
        <span class="t-label">Exit Velocity</span
        ><span class="t-val" id="t-ev">‚Äî</span>
      </div>
      <div class="t-row">
        <span class="t-label">Surface Speed</span
        ><span class="t-val" id="t-ss">‚Äî</span>
      </div>
      <div class="t-row">
        <span class="t-label">Apex Height</span
        ><span class="t-val" id="t-ah">‚Äî</span>
      </div>
      <div class="t-row">
        <span class="t-label">Apex above Hub</span
        ><span class="t-val" id="t-ac">‚Äî</span>
      </div>
      <div class="t-row">
        <span class="t-label">Descent Angle</span
        ><span class="t-val" id="t-da">‚Äî</span>
      </div>
      <div class="t-row">
        <span class="t-label">Time of Flight</span
        ><span class="t-val" id="t-tof">‚Äî</span>
      </div>
      <div class="t-row">
        <span class="t-label">Entry Margin</span
        ><span class="t-val" id="t-em">‚Äî</span>
      </div>
      <div class="t-row">
        <span class="t-label">Rim Clearance</span
        ><span class="t-val" id="t-rc">‚Äî</span>
      </div>
      <div class="t-row">
        <span class="t-label">Score?</span
        ><span class="t-val" id="t-score">‚Äî</span>
      </div>
    </div>

    <!-- BOTTOM STATS BAR -->
    <div class="bot-bar">
      <div class="stat">
        <span class="v a" id="b-dist">3.5</span
        ><span class="l">Distance (m)</span>
      </div>
      <div class="stat">
        <span class="v p" id="b-apex">2.1</span><span class="l">Apex (m)</span>
      </div>
      <div class="stat">
        <span class="v u" id="b-desc">48</span><span class="l">Descent¬∞</span>
      </div>
      <div class="stat">
        <span class="v y" id="b-clear">0.3</span
        ><span class="l">Clearance (m)</span>
      </div>
      <div class="ready-pill no" id="b-ready">CALCULATING</div>
    </div>

    <div class="keys">
      <kbd>Space</kbd> Fire &nbsp; <kbd>Drag</kbd> Orbit &nbsp;
      <kbd>Scroll</kbd> Zoom
    </div>
    <div class="score-popup" id="score-popup">SCORE!</div>

    <script>
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // CONSTANTS
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      const C = {
        ballDiam: 0.15, // Already correct for 2026 FUEL!
        ballR: 0.075,
        ballMass: 0.215, // Verify the official weight of the foam FUEL
        hubHeight: 1.82, // <-- CHANGE THIS: Enter the new TE-26300 Hub height (in meters)
        hubInnerDiam: 1.05, // <-- CHANGE THIS: Enter the top opening diameter of the 2026 Hub Funnel
        hubRimThickness: 0.04,
        exitH: 0.61,
        turretH: 0.45,
        hoodH: 0.5,
        hoodMin: 27.5,
        hoodMax: 42.5,
        botFwDiam: 0.1016,
        topFwDiam: 0.0508,
        minDist: 1.2,
        maxDist: 6.5,
        g: 9.81,
      };
      const hubR = C.hubInnerDiam / 2;

      let eff = 0.3,
        apexClear = 0.3,
        biasNear = 1.0,
        biasFar = 1.0;

      // Toggle states
      let showTraj = true,
        showApexM = true,
        showClear = true,
        showSide = true,
        autoRot = false;

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // PHYSICS (from ShooterPhysics.java)
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      function hoodToExit(hoodDeg) {
        const eMin = 90 - C.hoodMin,
          eMax = 90 - C.hoodMax;
        const f = (hoodDeg - C.hoodMin) / (C.hoodMax - C.hoodMin);
        return eMin - f * (eMin - eMax);
      }

      function biasAt(d) {
        const r = C.maxDist - C.minDist;
        if (r <= 0) return biasNear;
        const t = Math.max(0, Math.min(1, (d - C.minDist) / r));
        return biasNear + t * (biasFar - biasNear);
      }

      function trajVel(dist, aRad, dH) {
        const excess = dist * Math.tan(aRad) - dH;
        if (excess <= 0) return 25.0;
        return (dist / Math.cos(aRad)) * Math.sqrt(C.g / (2 * excess));
      }

      function apexVel(aRad, climb) {
        if (climb <= 0) return 0;
        const s = Math.sin(aRad);
        if (s <= 0) return 25.0;
        return Math.sqrt(2 * C.g * climb) / s;
      }

      function v2rps(v) {
        return v / (Math.PI * C.botFwDiam * eff);
      }
      function rps2v(r) {
        return r * Math.PI * C.botFwDiam * eff;
      }

      function computeShot(dist) {
        const dH = C.hubHeight - C.exitH;
        const t = Math.max(
          0,
          Math.min(1, (dist - C.minDist) / (C.maxDist - C.minDist)),
        );
        const hoodAng = C.hoodMin + t * (C.hoodMax - C.hoodMin);
        const exitDeg = hoodToExit(hoodAng);
        const exitRad = (exitDeg * Math.PI) / 180;

        // Constraint 1: arrive at hub height
        const vTraj = trajVel(dist, exitRad, dH);
        // Constraint 2: apex must be above hub + clearance
        const vApex = apexVel(exitRad, dH + apexClear);
        // Take higher
        let exitV = Math.max(vTraj, vApex);
        // Apply bias
        exitV *= biasAt(dist);

        const rps = v2rps(exitV);
        const vx = exitV * Math.cos(exitRad);
        const vy0 = exitV * Math.sin(exitRad);
        const tof = vx > 0.01 ? dist / vx : 2;
        const vyHub = vy0 - C.g * tof;
        const descDeg =
          vyHub < 0 ? (Math.atan(Math.abs(vyHub) / vx) * 180) / Math.PI : 0;
        const apexH = C.exitH + (vy0 * vy0) / (2 * C.g);
        const apexAboveHub = apexH - C.hubHeight;
        const surfSpeed = rps * Math.PI * C.botFwDiam;
        const geoMargin = (C.hubInnerDiam - C.ballDiam) / 2;
        const entryMargin = geoMargin * Math.sin((descDeg * Math.PI) / 180);

        // Apex horizontal position: where does the ball peak?
        const tApex = vy0 / C.g; // time to reach apex
        const xApex = vx * tApex; // horizontal distance at apex

        // Ball height at the hub rim edges (at x = dist ¬± hubR)
        // Height at x: y(x) = exitH + vy0*(x/vx) - 0.5*g*(x/vx)^2
        function heightAt(x) {
          const tt = x / vx;
          return C.exitH + vy0 * tt - 0.5 * C.g * tt * tt;
        }
        const nearEdgeX = dist - hubR;
        const farEdgeX = dist + hubR;
        const hNearEdge = heightAt(nearEdgeX);
        const hFarEdge = heightAt(farEdgeX);
        // Rim clearance: ball center height at edge minus hub height minus ball radius
        const nearRimClear = hNearEdge - C.hubHeight - C.ballR;
        const farRimClear = hFarEdge - C.hubHeight - C.ballR;
        const minRimClear = Math.min(nearRimClear, farRimClear);

        // Ball height at hub center
        const hAtCenter = heightAt(dist);
        // Does ball actually descend through? It must be descending (vyHub < 0)
        // and be near hub height at hub distance
        const isDescending = vyHub < 0;
        const landsInHub =
          isDescending && Math.abs(hAtCenter - C.hubHeight) < 0.5;
        const clearsEdges = minRimClear > 0;
        const scores = landsInHub && clearsEdges && apexAboveHub >= 0;

        return {
          hoodAng,
          exitDeg,
          exitRad,
          exitV,
          rps,
          vx,
          vy0,
          tof,
          descDeg,
          apexH,
          apexAboveHub,
          surfSpeed,
          entryMargin,
          minRimClear,
          xApex,
          tApex,
          nearEdgeX,
          farEdgeX,
          hNearEdge,
          hFarEdge,
          scores,
          heightAt,
        };
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // THREE.JS SCENE
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      let scene, camera, renderer, clock;
      let robotGroup, turretGroup, hoodGroup, fwBot, fwTop;
      let hubGroup, hubRimNear, hubRimFar;
      let trajLine, trajGlow, apexMarker, apexLine;
      let clearNearLine, clearFarLine, clearNearDot, clearFarDot;
      let sideGuide, gridHelper;
      let balls = [];

      function init() {
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x07090d, 0.03);

        camera = new THREE.PerspectiveCamera(
          50,
          innerWidth / innerHeight,
          0.1,
          100,
        );
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(innerWidth, innerHeight);
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.1;
        document.body.appendChild(renderer.domElement);

        clock = new THREE.Clock();

        // Lights
        scene.add(new THREE.AmbientLight(0x334466, 0.5));
        const sun = new THREE.DirectionalLight(0xffffff, 0.7);
        sun.position.set(5, 12, 5);
        sun.castShadow = true;
        sun.shadow.mapSize.set(2048, 2048);
        sun.shadow.camera.left = -10;
        sun.shadow.camera.right = 10;
        sun.shadow.camera.top = 10;
        sun.shadow.camera.bottom = -10;
        scene.add(sun);
        scene.add(
          new THREE.DirectionalLight(0x38bdf8, 0.25)
            .translateX(-3)
            .translateY(4),
        );
        scene.add(
          new THREE.DirectionalLight(0xf472b6, 0.15)
            .translateZ(5)
            .translateY(3),
        );

        // Ground
        const gnd = new THREE.Mesh(
          new THREE.PlaneGeometry(30, 30),
          new THREE.MeshStandardMaterial({ color: 0x12151c, roughness: 0.9 }),
        );
        gnd.rotation.x = -Math.PI / 2;
        gnd.receiveShadow = true;
        scene.add(gnd);

        gridHelper = new THREE.GridHelper(20, 40, 0x1a2540, 0x0d1220);
        gridHelper.position.y = 0.002;
        scene.add(gridHelper);

        // Distance rings
        for (let d = 1; d <= 7; d++) {
          const inRange = d >= C.minDist && d <= C.maxDist;
          const ring = new THREE.Mesh(
            new THREE.RingGeometry(d - 0.015, d + 0.015, 64),
            new THREE.MeshBasicMaterial({
              color: inRange ? 0x38bdf8 : 0x1e293b,
              transparent: true,
              opacity: inRange ? 0.12 : 0.06,
              side: THREE.DoubleSide,
            }),
          );
          ring.rotation.x = -Math.PI / 2;
          ring.position.y = 0.004;
          scene.add(ring);
        }

        buildRobot();
        buildHub();
        buildOverlays();
        setupOrbit();

        addEventListener("resize", () => {
          camera.aspect = innerWidth / innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(innerWidth, innerHeight);
        });
        addEventListener("keydown", (e) => {
          if (e.code === "Space") {
            e.preventDefault();
            fireBall();
          }
        });

        // Bind sliders
        ["s-dist", "s-turret", "s-eff", "s-apex", "s-bn", "s-bf"].forEach(
          (id) => document.getElementById(id).addEventListener("input", update),
        );

        update();
        animate();
      }

      // ‚îÄ‚îÄ ROBOT ‚îÄ‚îÄ
      function buildRobot() {
        robotGroup = new THREE.Group();
        const cMat = new THREE.MeshStandardMaterial({
          color: 0x2d3748,
          roughness: 0.4,
          metalness: 0.6,
        });

        // Chassis
        const chassis = new THREE.Mesh(
          new THREE.BoxGeometry(0.55, 0.11, 0.55),
          cMat,
        );
        chassis.position.y = 0.14;
        chassis.castShadow = true;
        robotGroup.add(chassis);

        // Bumpers
        const bMat = new THREE.MeshStandardMaterial({
          color: 0x3b82f6,
          roughness: 0.5,
        });
        [
          [0, 0.14, -0.3, 0.62, 0.09, 0.03],
          [0, 0.14, 0.3, 0.62, 0.09, 0.03],
          [-0.3, 0.14, 0, 0.03, 0.09, 0.62],
          [0.3, 0.14, 0, 0.03, 0.09, 0.62],
        ].forEach(([x, y, z, w, h, d]) => {
          const b = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), bMat);
          b.position.set(x, y, z);
          robotGroup.add(b);
        });

        // Forward arrow
        const arr = new THREE.Mesh(
          new THREE.ConeGeometry(0.035, 0.09, 8),
          new THREE.MeshBasicMaterial({ color: 0x4ade80 }),
        );
        arr.position.set(0.32, 0.2, 0);
        arr.rotation.z = -Math.PI / 2;
        robotGroup.add(arr);

        // Wheels
        const wMat = new THREE.MeshStandardMaterial({
          color: 0x111827,
          roughness: 0.3,
          metalness: 0.8,
        });
        [
          [-0.2, -0.2],
          [0.2, -0.2],
          [-0.2, 0.2],
          [0.2, 0.2],
        ].forEach(([x, z]) => {
          const w = new THREE.Mesh(
            new THREE.CylinderGeometry(0.045, 0.045, 0.035, 12),
            wMat,
          );
          w.position.set(x, 0.045, z);
          w.rotation.x = Math.PI / 2;
          robotGroup.add(w);
        });

        // Turret
        turretGroup = new THREE.Group();
        turretGroup.position.y = C.turretH;

        const tBase = new THREE.Mesh(
          new THREE.CylinderGeometry(0.13, 0.16, 0.07, 20),
          new THREE.MeshStandardMaterial({
            color: 0x475569,
            roughness: 0.3,
            metalness: 0.7,
          }),
        );
        turretGroup.add(tBase);

        const barrel = new THREE.Mesh(
          new THREE.BoxGeometry(0.22, 0.1, 0.12),
          new THREE.MeshStandardMaterial({
            color: 0x64748b,
            roughness: 0.3,
            metalness: 0.8,
          }),
        );
        barrel.position.set(0.11, 0.05, 0);
        turretGroup.add(barrel);

        hoodGroup = new THREE.Group();
        hoodGroup.position.set(0.2, 0.06, 0);

        const hd = new THREE.Mesh(
          new THREE.BoxGeometry(0.07, 0.12, 0.1),
          new THREE.MeshStandardMaterial({
            color: 0x94a3b8,
            roughness: 0.3,
            metalness: 0.5,
          }),
        );
        hoodGroup.add(hd);

        fwBot = new THREE.Mesh(
          new THREE.CylinderGeometry(0.048, 0.048, 0.1, 14),
          new THREE.MeshStandardMaterial({
            color: 0xf472b6,
            roughness: 0.2,
            metalness: 0.9,
            emissive: 0xf472b6,
            emissiveIntensity: 0.2,
          }),
        );
        fwBot.rotation.x = Math.PI / 2;
        fwBot.position.set(-0.035, -0.035, 0);
        hoodGroup.add(fwBot);

        fwTop = new THREE.Mesh(
          new THREE.CylinderGeometry(0.024, 0.024, 0.1, 14),
          new THREE.MeshStandardMaterial({
            color: 0xa78bfa,
            roughness: 0.2,
            metalness: 0.9,
            emissive: 0xa78bfa,
            emissiveIntensity: 0.2,
          }),
        );
        fwTop.rotation.x = Math.PI / 2;
        fwTop.position.set(-0.035, 0.035, 0);
        hoodGroup.add(fwTop);

        // Exit point glow
        const exitGlow = new THREE.Mesh(
          new THREE.SphereGeometry(0.018, 8, 8),
          new THREE.MeshBasicMaterial({
            color: 0xfbbf24,
            transparent: true,
            opacity: 0.8,
          }),
        );
        exitGlow.position.set(0.04, 0, 0);
        hoodGroup.add(exitGlow);

        turretGroup.add(hoodGroup);
        robotGroup.add(turretGroup);

        // Turret glow ring
        const gr = new THREE.Mesh(
          new THREE.RingGeometry(0.14, 0.17, 28),
          new THREE.MeshBasicMaterial({
            color: 0x38bdf8,
            transparent: true,
            opacity: 0.12,
            side: THREE.DoubleSide,
          }),
        );
        gr.rotation.x = -Math.PI / 2;
        gr.position.y = C.turretH - 0.03;
        robotGroup.add(gr);

        scene.add(robotGroup);
      }

      // ‚îÄ‚îÄ HUB ‚îÄ‚îÄ
      function buildHub() {
        hubGroup = new THREE.Group();

        // Main cylinder
        const cyl = new THREE.Mesh(
          new THREE.CylinderGeometry(hubR, hubR + 0.04, 0.35, 32, 1, true),
          new THREE.MeshStandardMaterial({
            color: 0x38bdf8,
            transparent: true,
            opacity: 0.12,
            side: THREE.DoubleSide,
          }),
        );
        cyl.position.y = C.hubHeight;
        hubGroup.add(cyl);

        // Top rim (this is what the ball must clear!)
        const rimGeo = new THREE.TorusGeometry(hubR, C.hubRimThickness, 8, 48);
        const rimMat = new THREE.MeshStandardMaterial({
          color: 0x38bdf8,
          roughness: 0.3,
          metalness: 0.8,
          emissive: 0x38bdf8,
          emissiveIntensity: 0.5,
        });
        const rimTop = new THREE.Mesh(rimGeo, rimMat);
        rimTop.rotation.x = Math.PI / 2;
        rimTop.position.y = C.hubHeight + 0.175;
        hubGroup.add(rimTop);

        // Bottom rim
        const rimBot = new THREE.Mesh(rimGeo.clone(), rimMat.clone());
        rimBot.rotation.x = Math.PI / 2;
        rimBot.position.y = C.hubHeight - 0.175;
        hubGroup.add(rimBot);

        // Near and far edge markers (in the shooting plane)
        const edgeMat = new THREE.MeshBasicMaterial({
          color: 0xf87171,
          transparent: true,
          opacity: 0.6,
        });
        hubRimNear = new THREE.Mesh(
          new THREE.SphereGeometry(0.04, 8, 8),
          edgeMat,
        );
        hubRimNear.position.y = C.hubHeight + 0.175;
        hubGroup.add(hubRimNear);

        hubRimFar = new THREE.Mesh(
          new THREE.SphereGeometry(0.04, 8, 8),
          edgeMat.clone(),
        );
        hubRimFar.position.y = C.hubHeight + 0.175;
        hubGroup.add(hubRimFar);

        // Scoring zone disc (inside hub)
        const disc = new THREE.Mesh(
          new THREE.CircleGeometry(hubR - 0.06, 32),
          new THREE.MeshBasicMaterial({
            color: 0x4ade80,
            transparent: true,
            opacity: 0.06,
            side: THREE.DoubleSide,
          }),
        );
        disc.rotation.x = -Math.PI / 2;
        disc.position.y = C.hubHeight;
        hubGroup.add(disc);

        // Support pole
        const pole = new THREE.Mesh(
          new THREE.CylinderGeometry(0.035, 0.035, C.hubHeight - 0.2, 8),
          new THREE.MeshStandardMaterial({
            color: 0x1e293b,
            roughness: 0.5,
            metalness: 0.5,
          }),
        );
        pole.position.y = (C.hubHeight - 0.2) / 2;
        pole.castShadow = true;
        hubGroup.add(pole);

        // Height reference line
        const hLine = new THREE.Line(
          new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, C.hubHeight + 0.2, 0),
          ]),
          new THREE.LineBasicMaterial({
            color: 0x38bdf8,
            transparent: true,
            opacity: 0.08,
          }),
        );
        hubGroup.add(hLine);

        scene.add(hubGroup);
      }

      // ‚îÄ‚îÄ TRAJECTORY & OVERLAY OBJECTS ‚îÄ‚îÄ
      function buildOverlays() {
        const N = 120;
        const pts = Array.from({ length: N }, () => new THREE.Vector3());

        // Main arc
        trajLine = new THREE.Line(
          new THREE.BufferGeometry().setFromPoints(pts),
          new THREE.LineBasicMaterial({
            color: 0xf472b6,
            transparent: true,
            opacity: 0.85,
          }),
        );
        scene.add(trajLine);

        // Glow arc
        trajGlow = new THREE.Line(
          new THREE.BufferGeometry().setFromPoints(pts.map((p) => p.clone())),
          new THREE.LineBasicMaterial({
            color: 0xf472b6,
            transparent: true,
            opacity: 0.2,
          }),
        );
        scene.add(trajGlow);

        // Apex marker
        apexMarker = new THREE.Mesh(
          new THREE.SphereGeometry(0.04, 12, 12),
          new THREE.MeshBasicMaterial({
            color: 0xa78bfa,
            transparent: true,
            opacity: 0.9,
          }),
        );
        scene.add(apexMarker);

        // Apex vertical dashed line
        const apexPts = [new THREE.Vector3(), new THREE.Vector3()];
        apexLine = new THREE.Line(
          new THREE.BufferGeometry().setFromPoints(apexPts),
          new THREE.LineBasicMaterial({
            color: 0xa78bfa,
            transparent: true,
            opacity: 0.25,
          }),
        );
        scene.add(apexLine);

        // Clearance dots at rim edges (shows where ball crosses hub rim plane)
        clearNearDot = new THREE.Mesh(
          new THREE.SphereGeometry(0.035, 8, 8),
          new THREE.MeshBasicMaterial({ color: 0x4ade80 }),
        );
        scene.add(clearNearDot);

        clearFarDot = new THREE.Mesh(
          new THREE.SphereGeometry(0.035, 8, 8),
          new THREE.MeshBasicMaterial({ color: 0x4ade80 }),
        );
        scene.add(clearFarDot);

        // Clearance vertical lines (ball height at rim edge ‚Üí hub rim)
        clearNearLine = new THREE.Line(
          new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(),
            new THREE.Vector3(),
          ]),
          new THREE.LineBasicMaterial({
            color: 0x4ade80,
            transparent: true,
            opacity: 0.4,
          }),
        );
        scene.add(clearNearLine);

        clearFarLine = new THREE.Line(
          new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(),
            new THREE.Vector3(),
          ]),
          new THREE.LineBasicMaterial({
            color: 0x4ade80,
            transparent: true,
            opacity: 0.4,
          }),
        );
        scene.add(clearFarLine);

        // Side-view guide: hub height horizontal reference
        sideGuide = new THREE.Line(
          new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(-1, C.hubHeight, 0),
            new THREE.Vector3(8, C.hubHeight, 0),
          ]),
          new THREE.LineBasicMaterial({
            color: 0x38bdf8,
            transparent: true,
            opacity: 0.08,
          }),
        );
        scene.add(sideGuide);
      }

      function updateOverlays(shot, dist, tRad) {
        const N = 120;
        const pos = trajLine.geometry.attributes.position.array;
        const gpos = trajGlow.geometry.attributes.position.array;

        // Generate full trajectory from exit to well past hub
        const tEnd = shot.tof * 1.15;
        let lastValid = 0;
        for (let i = 0; i < N; i++) {
          const t = (i / (N - 1)) * tEnd;
          const x = shot.vx * t;
          const y = C.exitH + shot.vy0 * t - 0.5 * C.g * t * t;
          const idx = i * 3;

          if (y < -0.2) {
            // Below ground ‚Äî collapse to last valid
            pos[idx] = pos[lastValid * 3];
            pos[idx + 1] = pos[lastValid * 3 + 1];
            pos[idx + 2] = pos[lastValid * 3 + 2];
            gpos[idx] = pos[idx];
            gpos[idx + 1] = pos[idx + 1];
            gpos[idx + 2] = pos[idx + 2];
          } else {
            const px = x * Math.cos(tRad);
            const pz = -x * Math.sin(tRad);
            pos[idx] = px;
            pos[idx + 1] = y;
            pos[idx + 2] = pz;
            gpos[idx] = px;
            gpos[idx + 1] = y;
            gpos[idx + 2] = pz;
            lastValid = i;
          }
        }
        trajLine.geometry.attributes.position.needsUpdate = true;
        trajGlow.geometry.attributes.position.needsUpdate = true;
        trajLine.visible = showTraj;
        trajGlow.visible = showTraj;

        // Apex marker
        const apexX = shot.xApex;
        const apexY = shot.apexH;
        apexMarker.position.set(
          apexX * Math.cos(tRad),
          apexY,
          -apexX * Math.sin(tRad),
        );
        apexMarker.visible = showApexM;

        // Apex line (vertical from ground to apex)
        const alPos = apexLine.geometry.attributes.position.array;
        alPos[0] = apexX * Math.cos(tRad);
        alPos[1] = 0;
        alPos[2] = -apexX * Math.sin(tRad);
        alPos[3] = apexX * Math.cos(tRad);
        alPos[4] = apexY;
        alPos[5] = -apexX * Math.sin(tRad);
        apexLine.geometry.attributes.position.needsUpdate = true;
        apexLine.visible = showApexM;

        // Edge clearance markers
        const nearX = shot.nearEdgeX;
        const farX = shot.farEdgeX;
        const nearH = shot.hNearEdge;
        const farH = shot.hFarEdge;
        const hubTop = C.hubHeight + 0.175;

        // Position rim edge markers on hub
        hubRimNear.position.set(-hubR, C.hubHeight + 0.175, 0);
        hubRimFar.position.set(hubR, C.hubHeight + 0.175, 0);

        // Near edge clearance dot (ball position at near rim edge)
        clearNearDot.position.set(
          nearX * Math.cos(tRad),
          nearH,
          -nearX * Math.sin(tRad),
        );
        const nearClears = nearH - hubTop - C.ballR > 0;
        clearNearDot.material.color.setHex(nearClears ? 0x4ade80 : 0xf87171);
        clearNearDot.visible = showClear;

        // Far edge clearance dot
        clearFarDot.position.set(
          farX * Math.cos(tRad),
          farH,
          -farX * Math.sin(tRad),
        );
        const farClears = farH - hubTop - C.ballR > 0;
        clearFarDot.material.color.setHex(farClears ? 0x4ade80 : 0xf87171);
        clearFarDot.visible = showClear;

        // Clearance vertical lines (from ball at edge ‚Üí hub rim height)
        const cnPos = clearNearLine.geometry.attributes.position.array;
        cnPos[0] = nearX * Math.cos(tRad);
        cnPos[1] = hubTop;
        cnPos[2] = -nearX * Math.sin(tRad);
        cnPos[3] = nearX * Math.cos(tRad);
        cnPos[4] = nearH;
        cnPos[5] = -nearX * Math.sin(tRad);
        clearNearLine.geometry.attributes.position.needsUpdate = true;
        clearNearLine.material.color.setHex(nearClears ? 0x4ade80 : 0xf87171);
        clearNearLine.visible = showClear;

        const cfPos = clearFarLine.geometry.attributes.position.array;
        cfPos[0] = farX * Math.cos(tRad);
        cfPos[1] = hubTop;
        cfPos[2] = -farX * Math.sin(tRad);
        cfPos[3] = farX * Math.cos(tRad);
        cfPos[4] = farH;
        cfPos[5] = -farX * Math.sin(tRad);
        clearFarLine.geometry.attributes.position.needsUpdate = true;
        clearFarLine.material.color.setHex(farClears ? 0x4ade80 : 0xf87171);
        clearFarLine.visible = showClear;

        // Side guide
        const sgPos = sideGuide.geometry.attributes.position.array;
        sgPos[0] = -0.5 * Math.cos(tRad);
        sgPos[2] = 0.5 * Math.sin(tRad);
        sgPos[3] = (dist + 1.5) * Math.cos(tRad);
        sgPos[5] = -(dist + 1.5) * Math.sin(tRad);
        sideGuide.geometry.attributes.position.needsUpdate = true;
        sideGuide.visible = showSide;
      }

      // ‚îÄ‚îÄ ORBIT CAMERA ‚îÄ‚îÄ
      let drag = false,
        pMouse = { x: 0, y: 0 };
      let orbit = { theta: 0.8, phi: 0.65 };
      let oRadius = 7,
        oTarget = new THREE.Vector3(1.5, 1.4, 0);

      function setupOrbit() {
        const el = renderer.domElement;
        el.addEventListener("mousedown", (e) => {
          drag = true;
          pMouse = { x: e.clientX, y: e.clientY };
        });
        el.addEventListener("mousemove", (e) => {
          if (!drag) return;
          orbit.theta -= (e.clientX - pMouse.x) * 0.005;
          orbit.phi = Math.max(
            0.08,
            Math.min(1.5, orbit.phi - (e.clientY - pMouse.y) * 0.005),
          );
          pMouse = { x: e.clientX, y: e.clientY };
        });
        el.addEventListener("mouseup", () => (drag = false));
        el.addEventListener("mouseleave", () => (drag = false));
        el.addEventListener("wheel", (e) => {
          oRadius = Math.max(2.5, Math.min(16, oRadius + e.deltaY * 0.005));
        });
        // Touch
        el.addEventListener("touchstart", (e) => {
          if (e.touches.length === 1) {
            drag = true;
            pMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          }
        });
        el.addEventListener("touchmove", (e) => {
          if (!drag || e.touches.length !== 1) return;
          orbit.theta -= (e.touches[0].clientX - pMouse.x) * 0.005;
          orbit.phi = Math.max(
            0.08,
            Math.min(
              1.5,
              orbit.phi - (e.touches[0].clientY - pMouse.y) * 0.005,
            ),
          );
          pMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });
        el.addEventListener("touchend", () => (drag = false));
      }

      function updateCam() {
        if (autoRot && !drag) orbit.theta += 0.002;
        camera.position.set(
          oTarget.x + oRadius * Math.sin(orbit.phi) * Math.cos(orbit.theta),
          oTarget.y + oRadius * Math.cos(orbit.phi),
          oTarget.z + oRadius * Math.sin(orbit.phi) * Math.sin(orbit.theta),
        );
        camera.lookAt(oTarget);
      }

      // ‚îÄ‚îÄ BALL FIRING ‚îÄ‚îÄ
      function fireBall() {
        const dist = parseFloat(document.getElementById("s-dist").value);
        const tDeg = parseFloat(document.getElementById("s-turret").value);
        const tRad = (tDeg * Math.PI) / 180;
        const shot = computeShot(dist);

        const ballGeo = new THREE.SphereGeometry(C.ballR, 16, 16);
        const ballMat = new THREE.MeshStandardMaterial({
          color: 0xfbbf24,
          roughness: 0.5,
          metalness: 0.2,
          emissive: 0xfbbf24,
          emissiveIntensity: 0.4,
        });
        const ball = new THREE.Mesh(ballGeo, ballMat);
        ball.castShadow = true;
        scene.add(ball);

        // Trail
        const trailGeo = new THREE.BufferGeometry();
        const trailArr = new Float32Array(90 * 3);
        trailGeo.setAttribute(
          "position",
          new THREE.BufferAttribute(trailArr, 3),
        );
        const trail = new THREE.Points(
          trailGeo,
          new THREE.PointsMaterial({
            color: 0xfbbf24,
            size: 0.025,
            transparent: true,
            opacity: 0.5,
          }),
        );
        scene.add(trail);

        balls.push({
          mesh: ball,
          trail,
          trailBuf: [],
          vx: shot.vx,
          vy0: shot.vy0,
          tRad,
          t0: clock.getElapsedTime(),
          dist,
          shot,
          scored: false,
          alive: true,
        });
      }

      function updateBalls(now) {
        balls.forEach((b) => {
          if (!b.alive) return;
          const t = now - b.t0;
          const x = b.vx * t;
          const y = C.exitH + b.vy0 * t - 0.5 * C.g * t * t;

          if (y < -0.5 || t > 6) {
            b.alive = false;
            scene.remove(b.mesh);
            scene.remove(b.trail);
            return;
          }

          const px = x * Math.cos(b.tRad);
          const pz = -x * Math.sin(b.tRad);
          b.mesh.position.set(px, y, pz);

          // Trail
          b.trailBuf.push(px, y, pz);
          if (b.trailBuf.length > 90 * 3) b.trailBuf.splice(0, 3);
          const arr = b.trail.geometry.attributes.position.array;
          for (let i = 0; i < 90 * 3; i++)
            arr[i] =
              i < b.trailBuf.length
                ? b.trailBuf[i]
                : arr[Math.max(0, b.trailBuf.length - 3 + (i % 3))];
          b.trail.geometry.attributes.position.needsUpdate = true;

          // Score detection: ball descends through hub plane near hub center
          if (!b.scored && b.vy0 - C.g * t < 0) {
            // descending
            const hDist = Math.sqrt(px * px + pz * pz); // distance from origin
            const hubCenter = b.dist;
            const lateralError = Math.abs(hDist - hubCenter);
            if (
              Math.abs(y - C.hubHeight) < 0.15 &&
              lateralError < hubR - C.ballR &&
              b.shot.scores
            ) {
              b.scored = true;
              showScorePopup(true);
              // Flash hub green
              hubGroup.children.forEach((c) => {
                if (c.material && c.material.emissive) {
                  const orig = c.material.emissiveIntensity;
                  c.material.emissiveIntensity = 2.0;
                  setTimeout(() => (c.material.emissiveIntensity = orig), 400);
                }
              });
            }
          }

          // Miss detection: ball has gone well past hub and below hub height
          if (!b.scored && y < C.hubHeight - 1.0 && x > b.dist + 1.0) {
            b.scored = true; // mark so we don't spam
            showScorePopup(false);
          }
        });
        balls = balls.filter((b) => b.alive);
      }

      function showScorePopup(scored) {
        const el = document.getElementById("score-popup");
        el.textContent = scored ? "SCORE!" : "MISS";
        el.className = "score-popup show" + (scored ? "" : " miss");
        setTimeout(() => (el.className = "score-popup"), 1200);
      }

      // ‚îÄ‚îÄ UPDATE ‚îÄ‚îÄ
      function update() {
        const dist = parseFloat(document.getElementById("s-dist").value);
        const tDeg = parseFloat(document.getElementById("s-turret").value);
        const tRad = (tDeg * Math.PI) / 180;
        eff = parseFloat(document.getElementById("s-eff").value);
        apexClear = parseFloat(document.getElementById("s-apex").value);
        biasNear = parseFloat(document.getElementById("s-bn").value);
        biasFar = parseFloat(document.getElementById("s-bf").value);

        // UI values
        document.getElementById("v-dist").textContent = dist.toFixed(1) + " m";
        document.getElementById("v-turret").textContent = tDeg + "¬∞";
        document.getElementById("v-eff").textContent = eff.toFixed(2);
        document.getElementById("v-apex").textContent =
          apexClear.toFixed(2) + " m";
        document.getElementById("v-bn").textContent = biasNear.toFixed(2);
        document.getElementById("v-bf").textContent = biasFar.toFixed(2);

        const shot = computeShot(dist);

        // Telemetry
        document.getElementById("t-fw").textContent =
          shot.rps.toFixed(1) + " RPS";
        document.getElementById("t-hood").textContent =
          shot.hoodAng.toFixed(1) + "¬∞";
        document.getElementById("t-ea").textContent =
          shot.exitDeg.toFixed(1) + "¬∞";
        document.getElementById("t-ev").textContent =
          shot.exitV.toFixed(1) + " m/s";
        document.getElementById("t-ss").textContent =
          shot.surfSpeed.toFixed(1) + " m/s";
        document.getElementById("t-ah").textContent =
          shot.apexH.toFixed(2) + " m";

        const acEl = document.getElementById("t-ac");
        acEl.textContent =
          (shot.apexAboveHub >= 0 ? "+" : "") +
          shot.apexAboveHub.toFixed(2) +
          " m";
        acEl.className =
          "t-val " +
          (shot.apexAboveHub >= apexClear
            ? "good"
            : shot.apexAboveHub >= 0
              ? "warn"
              : "bad");

        const daEl = document.getElementById("t-da");
        daEl.textContent = shot.descDeg.toFixed(1) + "¬∞";
        daEl.className =
          "t-val " +
          (shot.descDeg > 50
            ? "good"
            : shot.descDeg > 40
              ? ""
              : shot.descDeg > 30
                ? "warn"
                : "bad");

        document.getElementById("t-tof").textContent =
          shot.tof.toFixed(3) + " s";
        document.getElementById("t-em").textContent =
          (shot.entryMargin * 100).toFixed(1) + " cm";

        const rcEl = document.getElementById("t-rc");
        rcEl.textContent = (shot.minRimClear * 100).toFixed(1) + " cm";
        rcEl.className =
          "t-val " +
          (shot.minRimClear > 0.05
            ? "good"
            : shot.minRimClear > 0
              ? "warn"
              : "bad");

        const scEl = document.getElementById("t-score");
        scEl.textContent = shot.scores ? "YES ‚úì" : "NO ‚úó";
        scEl.className = "t-val " + (shot.scores ? "good" : "bad");

        // Bottom bar
        document.getElementById("b-dist").textContent = dist.toFixed(1);
        document.getElementById("b-apex").textContent = shot.apexH.toFixed(2);
        document.getElementById("b-desc").textContent = shot.descDeg.toFixed(0);
        document.getElementById("b-clear").textContent = (
          shot.minRimClear * 100
        ).toFixed(0);
        const bClearEl = document.getElementById("b-clear");
        bClearEl.className =
          "v " +
          (shot.minRimClear > 0.05 ? "g" : shot.minRimClear > 0 ? "y" : "bad");

        const readyEl = document.getElementById("b-ready");
        const inRange = dist >= C.minDist && dist <= C.maxDist;
        if (shot.scores && inRange) {
          readyEl.textContent = "‚óè READY TO FIRE";
          readyEl.className = "ready-pill ok";
        } else {
          readyEl.textContent =
            "‚óè " +
            (!inRange
              ? "OUT OF RANGE"
              : shot.minRimClear <= 0
                ? "CLIPS RIM"
                : shot.apexAboveHub < 0
                  ? "ARC TOO LOW"
                  : "NOT READY");
          readyEl.className = "ready-pill no";
        }

        // 3D updates
        turretGroup.rotation.y = tRad;
        hoodGroup.rotation.z = shot.exitRad - 0.3;

        hubGroup.position.set(dist * Math.cos(tRad), 0, -dist * Math.sin(tRad));
        hubGroup.rotation.y = tRad; // face the robot

        updateOverlays(shot, dist, tRad);

        oTarget.set(
          dist * 0.4 * Math.cos(tRad),
          1.4,
          -dist * 0.4 * Math.sin(tRad),
        );
      }

      // ‚îÄ‚îÄ TOGGLES ‚îÄ‚îÄ
      function tog(id) {
        const el = document.getElementById("tg-" + id);
        const isOn = el.classList.toggle("on");
        if (id === "traj") showTraj = isOn;
        if (id === "apexm") showApexM = isOn;
        if (id === "clear") showClear = isOn;
        if (id === "side") showSide = isOn;
        if (id === "rot") autoRot = isOn;
        update();
      }

      // ‚îÄ‚îÄ ANIMATE ‚îÄ‚îÄ
      function animate() {
        requestAnimationFrame(animate);
        const now = clock.getElapsedTime();

        updateCam();
        updateBalls(now);

        // Spin flywheels
        const shot = computeShot(
          parseFloat(document.getElementById("s-dist").value),
        );
        const spd = shot.rps * 0.015;
        if (fwBot) fwBot.rotation.y += spd;
        if (fwTop) fwTop.rotation.y += spd * 2;

        // Pulse apex marker
        if (apexMarker.visible) {
          apexMarker.material.opacity = 0.6 + 0.3 * Math.sin(now * 3);
        }

        renderer.render(scene, camera);
      }

      init();
    </script>
  </body>
</html>
